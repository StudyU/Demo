#include <Windows.h>
#include <iostream>
using namespace std;
/*
https://www.baidu.com/link?url=_6t5cPHMoSvx0FaGaZbctjAA1BIEx4WCUCdjSp2KljBmw49nkx5nTJgZik4G4_bxAwZCzi_hYdFP3eDIogeQoeAGK__TsDnclI13kP7thdy&wd=&eqid=e8431254000171d7000000055a0aaa35

C++内存区域分为5个区域。分别是堆，栈，自由存储区，全局/静态存储区和常量存储区。
栈：由编译器在需要的时候分配，在不需要的时候自动清除的变量存储区。里面通常是局部变量，函数参数等。
堆：由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
自由存储区：由malloc等分配的内存块，和堆十分相似，不过它使用free来结束自己的生命。
全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的c语言中。全局变量又分为初始化的和未初始化的，在c++里面没有这个区分了，他们共同占用同一块内存。
常量存储区：这是一块比较特殊的存储区，里面存放的是常量，不允许修改。
C++内存区域中堆和栈的区别：
管理方式不同：栈是由编译器自动管理，无需我们手工控制；对于堆来说，释放由程序员完成，容易产生内存泄漏。
空间大小不同：一般来讲，在32为系统下面，堆内存可达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定空间大小的，
例如，在vc6下面，默认的栈大小好像是1M。当然，也可以自己修改：打开工程。 project-->setting-->link，在category中选中output，然后再reserve中设定堆栈的最大值和 commit。
能否产生碎片：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题。
生长方向不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方式是向下的，是向着内存地址减小的方向增长。
分配方式不同：堆都是动态分配的；栈有静态和动态两种分配方式。静态分配由编译器完成，比如局部变量的分配。动态分配由alloca函数进行、但栈的动态分配和堆是不同的，
它的动态分配由编译器进行释放，无需我们手工实现。
分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。
堆则是c/c++库函数提供的，机制很复杂。库函数会按照一定的算法进行分配。显然，堆的效率比栈要低得多。

进程内存中的映像，主要有代码区，堆（动态存储区，new/delete的动态数据），栈，静态存储区
内存区域地址从低到高的方向：代码区，静态存储区，堆，栈
堆”和“栈”是独立的概念平常说的“堆栈”实际上是两个概念：“堆”和“栈”。
在英文中，堆是heap，栈是stack，不知道什么时候，什么原因，在中文里，这两个不同的概念硬是被搞在一起了，所以，围绕这个混合词所发生的误解和争执这几年就没有断过。

“栈”一般是由硬件（CPU）实现的，CPU用栈来保存调用子程序（函数）时的返回地址，高级语言有时也用它作为局部变量的存储空间。

“堆”是个实实在在的软件概念，使用与否完全由编程者“显示地（explicitly）”决定，如malloc。

程序经过编译连接生成执行程序后，堆和栈的起始地址就已经确定了（具体说，是通过“连接程序”），在一个具有反向增长的栈的CPU上，数据空间可表示如下：

低　　　　->｜－－－－－－－－－－－－－－－－－｜
　　　　　　｜　全局量（所有已初始化量 .data，　｜
	  　　　｜　未初始化量 .bss ）　　　　　　　｜
	堆起始->｜－－－－－－－－－－－－－－－－－｜
			｜　　　　堆向高地址增长　　　　　　｜
			｜　　　　　　　　　　　　　　　　　｜
			｜　　　　　　　　　　　　　　　　　｜
			｜　　　　　自由空间　　　　　　　　｜
			｜　　　　　　　　　　　　　　　　　｜
			｜　　　　　　　　　　　　　　　　　｜
			｜　　　　栈向低地址增长　　　　　　｜
高　栈起始->｜－－－－－－－－－－－－－－－－－｜

在内存中，“堆”和“栈”共用全部的自由空间，只不过各自的起始地址和增长方向不同，
它们之间并没有一个固定的界限，如果在运行时，“堆”和 “栈”增长到发生了相互覆盖时，称为“栈堆冲突”，
系统肯定垮台。由于开销方面的原因，各种编译在实现中都没有考虑解决这个问题，只有靠设计者自己解决，比如增加内存等
*/
int a = 0;	// 全局初始化区
char* p1;	// 全局未初始化区
int main()
{
	int b = 1;	//栈
	char s[5] = "1aa";	// 栈
	char* p2;	// 栈
	char* p3 = "2133";	// 栈“2133/0”在常量区，p3在栈上
	static int c = 0;	// 全局(静态)初始区
	p1 = (char*)malloc(10);
	p2 = (char*)malloc(20);//p2是栈区，所指向地址在堆区，分配的10和20字节在堆区
	strcpy_s(p1, 8, "123456");//“123456/0”在常量区，编译器可能将它与p3所指向的“2133/0”优化成一个地方
	cout << "栈区：b=" << &b 
		<< "\ns[0]=" << &s[0]
		<< "\ns[1]=" << &s[1] << endl;
	cout << "堆区：p1=" << &p1
		<< "\np2=" << &p2 << endl;

	system("pause");
	return 0;
}