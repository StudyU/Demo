/************************************************************************/
/*
求 500 万以内的所有亲和数
如果两个数 a 和 b，a 的所有真因数之和等于 b,b 的所有真因数之和等于 a,则称 a,b 是一对
亲和数。
例如 220 和 284，1184 和 1210，2620 和 2924。
分析：
首先得明确到底是什么是亲和数?
亲和数问题最早是由毕达哥拉斯学派发现和研究的。 他们在研究数字的规律的时候发现有以
下性质特点的两个数：
220 的真因子是：1、2、4、5、10、11、20、22、44、55、110；
284 的真因子是：1、2、4、71、142。
而这两个数恰恰等于对方的真因子各自加起来的和（sum[i]表示数 i 的各个真因子的和），
即
220=1+2+4+71+142=sum[284],
284=1+2+4+5+10+11+20+22+44+55+110=sum[220]。
得 284 的真因子之和 sum[284]=220，且 220 的真因子之和 sum[220]=284，即有
sum[220]=sum[sum[284]]=284。
*/
/************************************************************************/
#include<stdio.h>
int sum[5000010]; //为防越界
int main()
{
	int i, j;
	for (i = 0; i <= 5000000; i++)
		sum[i] = 1; //1 是所有数的真因数所以全部置 1
	for (i = 2; i + i <= 5000000; i++) //预处理，预处理是 logN（调和级数）*N。
		//@litaoye：调和级数 1/2 + 1/3 + 1/4......的和近似为 ln(n)，
		//因此 O(n *(1/2 + 1/3 + 1/4......)) = O(n * ln(n)) = O(N*log(N))。
	{
		//5000000 以下最大的真因数是不超过它的一半的
		j = i + i; //因为真因数，所以不能算本身，所以从它的 2 倍开始
		while (j <= 5000000)
		{
			//将所有 i 的倍数的位置上加 i
			sum[j] += i;
			j += i;
		}
	}
	for (i = 220; i <= 5000000; i++) //扫描，O（N）。
	{
		// 一次遍历，因为知道最小是 220 和 284 因此从 220 开始
		if (sum[i] > i && sum[i] <= 5000000 && sum[sum[i]] == i)
		{
			//去重，不越界，满足亲和
			printf("%d %d \n",i,sum[i]);
		}
	}
	return 0;
}
